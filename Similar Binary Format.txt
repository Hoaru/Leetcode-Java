Given an array of positive integers a, your task is to count the number of pairs i and j (where 0 <= i < j < a.length ), such that a[i] and alj] have the same number of 1 s in their binary representations.

Example
For a = [3, 5, 1, 7, 8, 10, 62, 13], the output should be solution(a) = 5.
There are 5 pairs here that have the same number of 1 s in their binary representations:
a[0] = 3 = 11 (Binary), a[1] = 5 = 101 (Binary) -> ones = 2
a[0] = 3 = 11 (Binary), a[5] = 10 = 1010 (Binary) -> ones = 2
a[1] = 5 = 101 (Binary), a[5] = 10 = 1010 (Binary) -> ones = 2
a[2] = 1 = 1  (Binary), a[4] = 8 = 1000 (Binary) -> ones = 1
a[3] = 7 = 111 (Binary), a[7] = 13 = 1101 (Binary) -> ones = 3


import java.util.*;
public class Main {
    public static int getOnes(int e) {
        int res = 0;
        while (e != 0) {
            // e & 000001
            int curr = e & 1;
            res += curr;
            e >>= 1;
        }
        return res;
    }

    public static long solve(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i : arr) {
            int ones = getOnes(i);
            map.put(ones, map.getOrDefault(ones, 0) + 1);
        }
        long res = 0;
        for (int i : map.values()) {
            res += (long) i * (i - 1) / 2;
        }
        return res;
    }
    
    public static void main(String[] args) {
        System.out.print(solve(new int[]{1, 3, 5, 7, 8, 10, 13, 62}));
    }
}